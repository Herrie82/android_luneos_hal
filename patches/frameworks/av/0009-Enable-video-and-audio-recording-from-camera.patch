From a5de67fec332fd95fa38e44d0237f1159ca7fc71 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Vo=C3=9F?= <thomas.voss.bochum@gmail.com>
Date: Thu, 11 Feb 2016 15:43:33 +0100
Subject: [PATCH 09/10] Enable video and audio recording from camera.

Signed-off-by: Ondrej Kubik <ondrej.kubik@canonical.com>

Change-Id: I9f0c80bf75c0ee713d27fe4460e409cef51cd4c2
---
 include/media/camera_record_service.h              |  65 +++---
 media/libmedia/AudioRecordHybris.cpp               | 246 +++++++++++----------
 media/libmedia/AudioSystem.cpp                     |  37 +---
 media/libmedia/camera_record_service.cpp           |  22 +-
 .../libmediaplayerservice/StagefrightRecorder.cpp  |   9 +-
 5 files changed, 180 insertions(+), 199 deletions(-)

diff --git a/include/media/camera_record_service.h b/include/media/camera_record_service.h
index 2b6254a..f5e4938 100644
--- a/include/media/camera_record_service.h
+++ b/include/media/camera_record_service.h
@@ -34,6 +34,11 @@ class RecordThread;
 class ICameraRecordService : public IInterface
 {
 public:
+    struct Recording {
+        sp<IAudioRecord> ar;
+        sp<IMemory> cblk;
+        sp<IMemory> buffers;
+    };
     DECLARE_META_INTERFACE(CameraRecordService);
 
     static const char* exported_service_name() { return "android.media.ICameraRecordService"; }
@@ -42,14 +47,14 @@ public:
                                 uint32_t sampleRate,
                                 audio_format_t format,
                                 audio_channel_mask_t channelMask) = 0;
-    virtual sp<IAudioRecord> openRecord(
-                                uint32_t sampleRate,
-                                audio_format_t format,
-                                audio_channel_mask_t channelMask,
-                                size_t frameCount,
-                                pid_t tid,
-                                int *sessionId,
-                                status_t *status) = 0;
+    virtual Recording openRecord(
+        uint32_t sampleRate,
+        audio_format_t format,
+        audio_channel_mask_t channelMask,
+        size_t frameCount,
+        pid_t tid,
+        int *sessionId,
+        status_t *status) = 0;
 
 };
 
@@ -75,17 +80,17 @@ public:
     ~BpCameraRecordService();
 
     virtual status_t initRecord(
-                                uint32_t sampleRate,
-                                audio_format_t format,
-                                audio_channel_mask_t channelMask);
-    virtual sp<IAudioRecord> openRecord(
-                                uint32_t sampleRate,
-                                audio_format_t format,
-                                audio_channel_mask_t channelMask,
-                                size_t frameCount,
-                                pid_t tid,
-                                int *sessionId,
-                                status_t *status);
+        uint32_t sampleRate,
+        audio_format_t format,
+        audio_channel_mask_t channelMask);
+    virtual Recording openRecord(
+        uint32_t sampleRate,
+        audio_format_t format,
+        audio_channel_mask_t channelMask,
+        size_t frameCount,
+        pid_t tid,
+        int *sessionId,
+        status_t *status);
 };
 
 // ----------------------------------------------------------------------------
@@ -101,17 +106,17 @@ public:
     uint32_t nextUniqueId();
 
     virtual status_t initRecord(
-                                uint32_t sampleRate,
-                                audio_format_t format,
-                                audio_channel_mask_t channelMask);
-    virtual sp<IAudioRecord> openRecord(
-                                uint32_t sampleRate,
-                                audio_format_t format,
-                                audio_channel_mask_t channelMask,
-                                size_t frameCount,
-                                pid_t tid,
-                                int *sessionId,
-                                status_t *status);
+        uint32_t sampleRate,
+        audio_format_t format,
+        audio_channel_mask_t channelMask);
+    virtual Recording openRecord(
+        uint32_t sampleRate,
+        audio_format_t format,
+        audio_channel_mask_t channelMask,
+        size_t frameCount,
+        pid_t tid,
+        int *sessionId,
+        status_t *status);
 
 private:
     static sp<CameraRecordService>& service_instance();
diff --git a/media/libmedia/AudioRecordHybris.cpp b/media/libmedia/AudioRecordHybris.cpp
index e59fe30..6cd6509 100644
--- a/media/libmedia/AudioRecordHybris.cpp
+++ b/media/libmedia/AudioRecordHybris.cpp
@@ -43,7 +43,6 @@ status_t AudioRecord::getMinFrameCount(
         audio_format_t format,
         audio_channel_mask_t channelMask)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     if (frameCount == NULL) {
         return BAD_VALUE;
     }
@@ -94,7 +93,6 @@ AudioRecord::AudioRecord(
       mPreviousSchedulingGroup(SP_DEFAULT),
       mProxy(NULL)
 {
-    ALOGD("%s", __PRETTY_FUNCTION__);
     mStatus = set(inputSource, sampleRate, format, channelMask, frameCount, cbf, user,
             notificationFrames, false /*threadCanCallJava*/, sessionId, transferType, flags,
             pAttributes);
@@ -102,7 +100,6 @@ AudioRecord::AudioRecord(
 
 AudioRecord::~AudioRecord()
 {
-    ALOGD("%s", __PRETTY_FUNCTION__);
     if (mStatus == NO_ERROR) {
         // Make sure that callback function exits in the case where
         // it is looping on buffer empty condition in obtainBuffer().
@@ -262,6 +259,7 @@ status_t AudioRecord::set(
     mMarkerReached = false;
     mNewPosition = 0;
     mUpdatePeriod = 0;
+    // AudioSystem::acquireAudioSessionId(mSessionId, -1);
     mSequence = 1;
     mObservedSequence = mSequence;
     mInOverrun = false;
@@ -291,6 +289,7 @@ status_t AudioRecord::start(AudioSystem::sync_event_t event, int triggerSession)
 
     status_t status = NO_ERROR;
     if (!(flags & CBLK_INVALID)) {
+        ALOGV("mAudioRecord->start()");
         status = mAudioRecord->start(event, triggerSession);
         if (status == DEAD_OBJECT) {
             flags |= CBLK_INVALID;
@@ -314,12 +313,12 @@ status_t AudioRecord::start(AudioSystem::sync_event_t event, int triggerSession)
         }
     }
 
+    ALOGD("return status %d", status);
     return status;
 }
 
 void AudioRecord::stop()
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     AutoMutex lock(mLock);
     if (!mActive) {
         return;
@@ -338,18 +337,19 @@ void AudioRecord::stop()
         setpriority(PRIO_PROCESS, 0, mPreviousPriority);
         set_sched_policy(0, mPreviousSchedulingGroup);
     }
+
+    ALOGD("-%s", __FUNCTION__);
 }
 
 bool AudioRecord::stopped() const
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
+    ALOGD("%s", __FUNCTION__);
     AutoMutex lock(mLock);
     return !mActive;
 }
 
 status_t AudioRecord::setMarkerPosition(uint32_t marker)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     // The only purpose of setting marker position is to get a callback
     if (mCbf == NULL) {
         return INVALID_OPERATION;
@@ -364,7 +364,6 @@ status_t AudioRecord::setMarkerPosition(uint32_t marker)
 
 status_t AudioRecord::getMarkerPosition(uint32_t *marker) const
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     if (marker == NULL) {
         return BAD_VALUE;
     }
@@ -377,7 +376,6 @@ status_t AudioRecord::getMarkerPosition(uint32_t *marker) const
 
 status_t AudioRecord::setPositionUpdatePeriod(uint32_t updatePeriod)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     // The only purpose of setting position update period is to get a callback
     if (mCbf == NULL) {
         return INVALID_OPERATION;
@@ -392,7 +390,6 @@ status_t AudioRecord::setPositionUpdatePeriod(uint32_t updatePeriod)
 
 status_t AudioRecord::getPositionUpdatePeriod(uint32_t *updatePeriod) const
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     if (updatePeriod == NULL) {
         return BAD_VALUE;
     }
@@ -405,7 +402,6 @@ status_t AudioRecord::getPositionUpdatePeriod(uint32_t *updatePeriod) const
 
 status_t AudioRecord::getPosition(uint32_t *position) const
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     if (position == NULL) {
         return BAD_VALUE;
     }
@@ -418,7 +414,6 @@ status_t AudioRecord::getPosition(uint32_t *position) const
 
 uint32_t AudioRecord::getInputFramesLost() const
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     // no need to check mActive, because if inactive this will return 0, which is what we want
     return AudioSystem::getInputFramesLost(getInput());
 }
@@ -428,7 +423,7 @@ uint32_t AudioRecord::getInputFramesLost() const
 // must be called with mLock held
 status_t AudioRecord::openRecord_l(size_t epoch)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
+    ALOGD("%s", __FUNCTION__);
     status_t status;
     // Get an instance of the CameraRecordInstance over Binder
     const sp<ICameraRecordService>& recordService = AudioSystem::get_camera_record_service();
@@ -465,122 +460,146 @@ status_t AudioRecord::openRecord_l(size_t epoch)
         }
     }
 
+    audio_io_handle_t input;
+    status = AudioSystem::getInputForAttr(&mAttributes, &input, (audio_session_t)mSessionId,
+                                          mSampleRate, mFormat, mChannelMask, mFlags);
+
+    if (status != NO_ERROR) {
+        ALOGW("Could not get audio input for record source %d, sample rate %u, format %#x, "
+              "channel mask %#x, session %d, flags %#x",
+              mAttributes.source, mSampleRate, mFormat, mChannelMask, mSessionId, mFlags);
+        // return BAD_VALUE;
+    }
+
     // Initialize the input reader RecordThread:
     status = recordService->initRecord(mSampleRate, mFormat, mChannelMask);
     if (status != NO_ERROR) {
         ALOGE("Failed to initialize RecordThread: %s", strerror(status));
         return status;
     }
+
     {
     // Now that we have a reference to an I/O handle and have not yet handed it off to AudioFlinger,
     // we must release it ourselves if anything goes wrong.
 
+    size_t frameCount = mReqFrameCount;
+    size_t temp = frameCount;   // temp may be replaced by a revised value of frameCount,
+                                // but we will still need the original value also
     int originalSessionId = mSessionId;
-    sp<IAudioRecord> record = recordService->openRecord(mSampleRate, mFormat,
-                                                       mChannelMask,
-                                                       mFrameCount,
-                                                       tid,
-                                                       &mSessionId,
-                                                       &status);
 
+    // The notification frame count is the period between callbacks, as suggested by the server.
+    size_t notificationFrames = mNotificationFramesReq;
+
+    sp<IMemory> iMem;           // for cblk
+    sp<IMemory> bufferMem;
+    sp<IAudioRecord> record;
+
+    ICameraRecordService::Recording recording = recordService->openRecord(mSampleRate, mFormat,
+                                                                          mChannelMask,
+                                                                          frameCount,
+                                                                          tid,
+                                                                          &mSessionId,
+                                                                          &status);
+    
     ALOGE_IF(originalSessionId != AUDIO_SESSION_ALLOCATE && mSessionId != originalSessionId,
             "session ID changed from %d to %d", originalSessionId, mSessionId);
 
-    if (record == 0 || status != NO_ERROR) {
+    if (recording.ar == 0 || status != NO_ERROR) {
         ALOGE("CameraRecordService could not create record track, status: %d", status);
         goto release;
     }
-    ALOG_ASSERT(record != 0);
-
-//     sp<IMemory> iMem = record->getCblk();
-//
-//     // AudioFlinger now owns the reference to the I/O handle,
-//     // so we are no longer responsible for releasing it.
-//
-//     if (iMem == 0) {
-//         ALOGE("Could not get control block");
-//         return NO_INIT;
-//     }
-//     void *iMemPointer = iMem->pointer();
-//     if (iMemPointer == NULL) {
-//         ALOGE("Could not get control block pointer");
-//         return NO_INIT;
-//     }
-//     audio_track_cblk_t* cblk = static_cast<audio_track_cblk_t*>(iMemPointer);
-//
-//     // Starting address of buffers in shared memory.
-//     // The buffers are either immediately after the control block,
-//     // or in a separate area at discretion of server.
-//     void *buffers;
-//     if (bufferMem == 0) {
-//         buffers = cblk + 1;
-//     } else {
-//         buffers = bufferMem->pointer();
-//         if (buffers == NULL) {
-//             ALOGE("Could not get buffer pointer");
-//             return NO_INIT;
-//         }
-//     }
-//
-//     // invariant that mAudioRecord != 0 is true only after set() returns successfully
-//     if (mAudioRecord != 0) {
-//         mAudioRecord->asBinder()->unlinkToDeath(mDeathNotifier, this);
-//         mDeathNotifier.clear();
-//     }
-//     mAudioRecord = record;
-//     mCblkMemory = iMem;
-//     mBufferMemory = bufferMem;
-//     IPCThreadState::self()->flushCommands();
-//
-//     mCblk = cblk;
-//     // note that temp is the (possibly revised) value of frameCount
-//     if (temp < frameCount || (frameCount == 0 && temp == 0)) {
-//         ALOGW("Requested frameCount %zu but received frameCount %zu", frameCount, temp);
-//     }
-//     frameCount = temp;
-//
-//     mAwaitBoost = false;
-//     if (mFlags & AUDIO_INPUT_FLAG_FAST) {
-//         if (trackFlags & IAudioFlinger::TRACK_FAST) {
-//             ALOGV("AUDIO_INPUT_FLAG_FAST successful; frameCount %zu", frameCount);
-//             mAwaitBoost = true;
-//         } else {
-//             ALOGV("AUDIO_INPUT_FLAG_FAST denied by server; frameCount %zu", frameCount);
-//             // once denied, do not request again if IAudioRecord is re-created
-//             mFlags = (audio_input_flags_t) (mFlags & ~AUDIO_INPUT_FLAG_FAST);
-//         }
-//     }
-//
-//     // Make sure that application is notified with sufficient margin before overrun
-//     if (notificationFrames == 0 || notificationFrames > frameCount) {
-//         ALOGW("Received notificationFrames %zu for frameCount %zu", notificationFrames, frameCount);
-//     }
-//     mNotificationFramesAct = notificationFrames;
-//
-//     // We retain a copy of the I/O handle, but don't own the reference
-//     mInput = input;
-//     mRefreshRemaining = true;
-//
-//     mFrameCount = frameCount;
-//     // If IAudioRecord is re-created, don't let the requested frameCount
-//     // decrease.  This can confuse clients that cache frameCount().
-//     if (frameCount > mReqFrameCount) {
-//         mReqFrameCount = frameCount;
-//     }
-//
-//     // update proxy
-//     mProxy = new AudioRecordClientProxy(cblk, buffers, mFrameCount, mFrameSize);
-//     mProxy->setEpoch(epoch);
-//     mProxy->setMinimum(mNotificationFramesAct);
-//
-//     mDeathNotifier = new DeathNotifier(this);
-//     mAudioRecord->asBinder()->linkToDeath(mDeathNotifier, this);
+
+    record = recording.ar;
+    iMem = recording.cblk;
+    bufferMem = recording.buffers;
+    
+    // AudioFlinger now owns the reference to the I/O handle,
+    // so we are no longer responsible for releasing it.
+
+    if (iMem == 0) {
+        ALOGE("Could not get control block");
+        return NO_INIT;
+    }
+    void *iMemPointer = iMem->pointer();
+    if (iMemPointer == NULL) {
+        ALOGE("Could not get control block pointer");
+        return NO_INIT;
+    }
+    audio_track_cblk_t* cblk = static_cast<audio_track_cblk_t*>(iMemPointer);
+
+    // Starting address of buffers in shared memory.
+    // The buffers are either immediately after the control block,
+    // or in a separate area at discretion of server.
+    void *buffers;
+    if (bufferMem == 0) {
+        buffers = cblk + 1;
+    } else {
+        buffers = bufferMem->pointer();
+        if (buffers == NULL) {
+            ALOGE("Could not get buffer pointer");
+            return NO_INIT;
+        }
+    }
+
+    // invariant that mAudioRecord != 0 is true only after set() returns successfully
+    if (mAudioRecord != 0) {
+        mAudioRecord->asBinder()->unlinkToDeath(mDeathNotifier, this);
+        mDeathNotifier.clear();
+    }
+    mAudioRecord = record;
+    mCblkMemory = iMem;
+    mBufferMemory = bufferMem;
+    IPCThreadState::self()->flushCommands();
+
+    mCblk = cblk;
+    // note that temp is the (possibly revised) value of frameCount
+    if (temp < frameCount || (frameCount == 0 && temp == 0)) {
+        ALOGW("Requested frameCount %zu but received frameCount %zu", frameCount, temp);
+    }
+    frameCount = temp;
+
+    mAwaitBoost = false;
+    if (mFlags & AUDIO_INPUT_FLAG_FAST) {
+        if (trackFlags & IAudioFlinger::TRACK_FAST) {
+            ALOGV("AUDIO_INPUT_FLAG_FAST successful; frameCount %zu", frameCount);
+            mAwaitBoost = true;
+        } else {
+            ALOGV("AUDIO_INPUT_FLAG_FAST denied by server; frameCount %zu", frameCount);
+            // once denied, do not request again if IAudioRecord is re-created
+            mFlags = (audio_input_flags_t) (mFlags & ~AUDIO_INPUT_FLAG_FAST);
+        }
+    }
+
+    // Make sure that application is notified with sufficient margin before overrun
+    if (notificationFrames == 0 || notificationFrames > frameCount) {
+        ALOGW("Received notificationFrames %zu for frameCount %zu", notificationFrames, frameCount);
+    }
+    mNotificationFramesAct = notificationFrames;
+
+    // We retain a copy of the I/O handle, but don't own the reference
+    mInput = input;
+    mRefreshRemaining = true;
+
+    mFrameCount = frameCount;
+    // If IAudioRecord is re-created, don't let the requested frameCount
+    // decrease.  This can confuse clients that cache frameCount().
+    if (frameCount > mReqFrameCount) {
+        mReqFrameCount = frameCount;
+    }
+
+    // update proxy
+    mProxy = new AudioRecordClientProxy(cblk, buffers, mFrameCount, mFrameSize);
+    mProxy->setEpoch(epoch);
+    mProxy->setMinimum(mNotificationFramesAct);
+
+    mDeathNotifier = new DeathNotifier(this);
+    mAudioRecord->asBinder()->linkToDeath(mDeathNotifier, this);
 
     return NO_ERROR;
     }
 
 release:
-//    AudioSystem::releaseInput(input, (audio_session_t)mSessionId);
+    AudioSystem::releaseInput(input, (audio_session_t)mSessionId);
     if (status == NO_ERROR) {
         status = NO_INIT;
     }
@@ -589,7 +608,6 @@ release:
 
 status_t AudioRecord::obtainBuffer(Buffer* audioBuffer, int32_t waitCount)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     if (audioBuffer == NULL) {
         return BAD_VALUE;
     }
@@ -621,7 +639,6 @@ status_t AudioRecord::obtainBuffer(Buffer* audioBuffer, int32_t waitCount)
 status_t AudioRecord::obtainBuffer(Buffer* audioBuffer, const struct timespec *requested,
         struct timespec *elapsed, size_t *nonContig)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     // previous and new IAudioRecord sequence numbers are used to detect track re-creation
     uint32_t oldSequence = 0;
     uint32_t newSequence;
@@ -687,7 +704,6 @@ status_t AudioRecord::obtainBuffer(Buffer* audioBuffer, const struct timespec *r
 
 void AudioRecord::releaseBuffer(Buffer* audioBuffer)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     // all TRANSFER_* are valid
 
     size_t stepCount = audioBuffer->size / mFrameSize;
@@ -708,7 +724,6 @@ void AudioRecord::releaseBuffer(Buffer* audioBuffer)
 
 audio_io_handle_t AudioRecord::getInput() const
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     AutoMutex lock(mLock);
     return mInput;
 }
@@ -717,7 +732,6 @@ audio_io_handle_t AudioRecord::getInput() const
 
 ssize_t AudioRecord::read(void* buffer, size_t userSize)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     if (mTransfer != TRANSFER_SYNC) {
         return INVALID_OPERATION;
     }
@@ -759,7 +773,6 @@ ssize_t AudioRecord::read(void* buffer, size_t userSize)
 
 nsecs_t AudioRecord::processAudioBuffer()
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     mLock.lock();
     if (mAwaitBoost) {
         mAwaitBoost = false;
@@ -804,7 +817,7 @@ nsecs_t AudioRecord::processAudioBuffer()
         }
     }
 
-    // Get current position of server (units in frames)
+    // Get current position of server
     size_t position = mProxy->getPosition();
 
     // Manage marker callback
@@ -993,7 +1006,6 @@ nsecs_t AudioRecord::processAudioBuffer()
 
 status_t AudioRecord::restoreRecord_l(const char *from)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     ALOGW("dead IAudioRecord, creating a new one from %s()", from);
     ++mSequence;
     status_t result;
@@ -1023,7 +1035,6 @@ status_t AudioRecord::restoreRecord_l(const char *from)
 
 void AudioRecord::DeathNotifier::binderDied(const wp<IBinder>& who __unused)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     sp<AudioRecord> audioRecord = mAudioRecord.promote();
     if (audioRecord != 0) {
         AutoMutex lock(audioRecord->mLock);
@@ -1037,17 +1048,14 @@ AudioRecord::AudioRecordThread::AudioRecordThread(AudioRecord& receiver, bool bC
     : Thread(bCanCallJava), mReceiver(receiver), mPaused(true), mPausedInt(false), mPausedNs(0LL),
       mIgnoreNextPausedInt(false)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
 }
 
 AudioRecord::AudioRecordThread::~AudioRecordThread()
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
 }
 
 bool AudioRecord::AudioRecordThread::threadLoop()
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     {
         AutoMutex _l(mMyLock);
         if (mPaused) {
@@ -1091,7 +1099,6 @@ bool AudioRecord::AudioRecordThread::threadLoop()
 
 void AudioRecord::AudioRecordThread::requestExit()
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     // must be in this order to avoid a race condition
     Thread::requestExit();
     resume();
@@ -1099,14 +1106,12 @@ void AudioRecord::AudioRecordThread::requestExit()
 
 void AudioRecord::AudioRecordThread::pause()
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     AutoMutex _l(mMyLock);
     mPaused = true;
 }
 
 void AudioRecord::AudioRecordThread::resume()
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     AutoMutex _l(mMyLock);
     mIgnoreNextPausedInt = true;
     if (mPaused || mPausedInt) {
@@ -1118,7 +1123,6 @@ void AudioRecord::AudioRecordThread::resume()
 
 void AudioRecord::AudioRecordThread::pauseInternal(nsecs_t ns)
 {
-    ALOGV("%s", __PRETTY_FUNCTION__);
     AutoMutex _l(mMyLock);
     mPausedInt = true;
     mPausedNs = ns;
diff --git a/media/libmedia/AudioSystem.cpp b/media/libmedia/AudioSystem.cpp
index d2aea61..a40ce12 100644
--- a/media/libmedia/AudioSystem.cpp
+++ b/media/libmedia/AudioSystem.cpp
@@ -55,39 +55,7 @@ sp<AudioSystem::AudioPortCallback> AudioSystem::gAudioPortCallback;
 // establish binder interface to AudioFlinger service
 const sp<IAudioFlinger> AudioSystem::get_audio_flinger()
 {
-    sp<IAudioFlinger> af;
-    sp<AudioFlingerClient> afc;
-    {
-    ALOGV("%s", __PRETTY_FUNCTION__);
-        Mutex::Autolock _l(gLock);
-        if (gAudioFlinger == 0) {
-            sp<IServiceManager> sm = defaultServiceManager();
-            sp<IBinder> binder;
-            do {
-                binder = sm->getService(String16("media.audio_flinger"));
-                if (binder != 0)
-                    break;
-                ALOGW("AudioFlinger not published, waiting...");
-                usleep(500000); // 0.5 s
-            } while (true);
-            if (gAudioFlingerClient == NULL) {
-                gAudioFlingerClient = new AudioFlingerClient();
-            } else {
-                if (gAudioErrorCallback) {
-                    gAudioErrorCallback(NO_ERROR);
-                }
-            }
-            binder->linkToDeath(gAudioFlingerClient);
-            gAudioFlinger = interface_cast<IAudioFlinger>(binder);
-            LOG_ALWAYS_FATAL_IF(gAudioFlinger == 0);
-            afc = gAudioFlingerClient;
-        }
-        af = gAudioFlinger;
-    }
-    if (afc != 0) {
-        af->registerClient(afc);
-    }
-    return af;
+    return sp<IAudioFlinger>();
 }
 
 const sp<ICameraRecordService>& AudioSystem::get_camera_record_service()
@@ -775,7 +743,8 @@ status_t AudioSystem::getInputForAttr(const audio_attributes_t *attr,
                                 audio_input_flags_t flags)
 {
     ALOGV("Returning a static audio_io_handle_t == 1");
-    return 1;
+    if (input) *input = 1;
+    return NO_ERROR;
 }
 
 status_t AudioSystem::startInput(audio_io_handle_t input,
diff --git a/media/libmedia/camera_record_service.cpp b/media/libmedia/camera_record_service.cpp
index 56c7f9f..383534b 100644
--- a/media/libmedia/camera_record_service.cpp
+++ b/media/libmedia/camera_record_service.cpp
@@ -59,7 +59,7 @@ status_t BpCameraRecordService::initRecord(
     return remote()->transact(OPEN_RECORD, data, &reply);
 }
 
-sp<IAudioRecord> BpCameraRecordService::openRecord(uint32_t sampleRate,
+ICameraRecordService::Recording BpCameraRecordService::openRecord(uint32_t sampleRate,
                             audio_format_t format,
                             audio_channel_mask_t channelMask,
                             size_t frameCount,
@@ -71,6 +71,8 @@ sp<IAudioRecord> BpCameraRecordService::openRecord(uint32_t sampleRate,
 
     Parcel data, reply;
     sp<IAudioRecord> record;
+    sp<IMemory> memory;
+    sp<IMemory> buffers;
     data.writeInterfaceToken(ICameraRecordService::getInterfaceDescriptor());
     data.writeInt32(sampleRate);
     data.writeInt32(format);
@@ -88,6 +90,8 @@ sp<IAudioRecord> BpCameraRecordService::openRecord(uint32_t sampleRate,
     else {
         lStatus = reply.readInt32();
         record = interface_cast<IAudioRecord>(reply.readStrongBinder());
+        memory = interface_cast<IMemory>(reply.readStrongBinder());
+        buffers = interface_cast<IMemory>(reply.readStrongBinder());
         if (lStatus == NO_ERROR) {
             if (record == 0) {
                 ALOGE("openRecord should have returned an IAudioRecord instance");
@@ -103,7 +107,7 @@ sp<IAudioRecord> BpCameraRecordService::openRecord(uint32_t sampleRate,
     if (status)
         *status = lStatus;
 
-    return record;
+    return Recording{record, memory, buffers};
 }
 
 // ----------------------------------------------------------------------------
@@ -143,13 +147,17 @@ status_t BnCameraRecordService::onTransact(uint32_t code, const Parcel& data,
             pid_t tid = (pid_t) data.readInt32();
             int sessionId = data.readInt32();
             status_t status;
-            sp<IAudioRecord> record = openRecord(sampleRate, format, channelMask,
+
+            Recording recording = openRecord(sampleRate, format, channelMask,
                 frameCount, tid, &sessionId, &status);
-            LOG_ALWAYS_FATAL_IF((record != 0) != (status == NO_ERROR));
+            LOG_ALWAYS_FATAL_IF((recording.ar != 0) != (status == NO_ERROR));
 
             reply->writeInt32(sessionId);
             reply->writeInt32(status);
-            reply->writeStrongBinder(record->asBinder());
+            reply->writeStrongBinder(recording.ar->asBinder());
+            reply->writeStrongBinder(recording.cblk->asBinder());
+            if (recording.buffers != NULL)
+                reply->writeStrongBinder(recording.buffers->asBinder());
             return NO_ERROR;
         } break;
         default:
@@ -211,7 +219,7 @@ status_t CameraRecordService::initRecord(
     return NO_ERROR;
 }
 
-sp<IAudioRecord> CameraRecordService::openRecord(uint32_t sampleRate,
+ICameraRecordService::Recording CameraRecordService::openRecord(uint32_t sampleRate,
                             audio_format_t format,
                             audio_channel_mask_t channelMask,
                             size_t frameCount,
@@ -273,7 +281,7 @@ Exit:
     if (status) {
         *status = lStatus;
     }
-    return recordHandle;
+    return Recording{recordHandle, recordTrack->getCblk(), NULL};
 }
 
 sp<CameraRecordService>& CameraRecordService::service_instance()
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 29ccfe6..230da3f 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -73,13 +73,8 @@ namespace android {
 static const int64_t kMax32BitFileSize = 0x00ffffffffLL; // 4GB
 
 // To collect the encoder usage for the battery app
-static void addBatteryData(uint32_t params) {
-    sp<IBinder> binder =
-        defaultServiceManager()->getService(String16("media.player"));
-    sp<IMediaPlayerService> service = interface_cast<IMediaPlayerService>(binder);
-    CHECK(service.get() != NULL);
-
-    service->addBatteryData(params);
+static void addBatteryData(uint32_t) {
+    // Empty on purpose.
 }
 
 
-- 
2.7.4

